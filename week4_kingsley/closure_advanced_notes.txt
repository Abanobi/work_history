A closure is the combination of a function and the lexical
environment within which that function was declared.

function makeFunc() {
  var name = 'Mozilla';
  function displayName() {
    alert(name);
  }
  return displayName;
}

var myFunc = makeFunc();
myFunc();

Practical closures

Closures are useful because they let you associate some data
(the lexical environment) with a function that operates on that data.
 This has obvious parallels to object-oriented programming, where objects allow us
  to associate some data (the object's properties) with one or more methods.

  For instance, suppose we wish to add some buttons to a page that adjust the text size.
   One way of doing this is to specify the font-size of the body element in pixels,
    then set the size of the other elements on the page (such as headers) using the
     relative em unit:
     example:

     function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + 'px';
  };
}

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);

Emulating private methods with closures: Languages such as Java provide the ability
 to declare methods private, meaning that they can only be called by other methods
 in the same class.

 The following code illustrates how to use closures to define public functions
 that can access private functions and variables. Using closures in this way
 is known as the module pattern.

 var counter = (function() {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  };
})();

console.log(counter.value()); // logs 0
counter.increment();
counter.increment();
console.log(counter.value()); // logs 2
counter.decrement();
console.log(counter.value()); // logs 1
